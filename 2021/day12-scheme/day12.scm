(define (assoc-init) ())

(define (assoc-get m k default)
  (cond ((and (not (null? m)) (equal? (car (car m)) k)) (cdr (car m)))
        ((not (null? m)) (assoc-get (cdr m) k default))
        (else default)))

(define (assoc-put m k v)
  (cond ((and (not (null? m)) (equal? (car (car m)) k)) (cons (cons k v) (cdr m)))
        ((not (null? m)) (cons (car m) (assoc-put (cdr m) k v)))
        (else (cons (cons k v) ()))))

(define (string-split str ch)
  (let ((len (string-length str)))
    (letrec ((split (lambda (a b)
                      (cond ((>= b len) (if (= a b) '() (cons (substring str a b) '())))
                            ((char=? ch (string-ref str b)) (if (= a b)
                                                                (split (+ 1 a) (+ 1 b))
                                                                (cons (substring str a b) (split b b))))
                            (else (split a (+ 1 b)))))))
      (split 0 0))))

(define (read-input file-input-port graph)
  (let* ((line (read-line file-input-port)))
    (if (eof-object? line)
        graph
        (let* ((split (string-split line #\-))
               (from (car split))
               (to (car (cdr split)))
               (with-from-to (assoc-put graph from (cons to (assoc-get graph from ()))))
               (with-from-to-and-to-from (assoc-put with-from-to to (cons from (assoc-get with-from-to to ())))))
          (read-input file-input-port with-from-to-and-to-from)))))

(define (small-cave? cave-name)
  (char>=? (car (string->list cave-name)) #\a))

(define (big-cave? cave-name)
  (not (small-cave? cave-name)))

(define (append-all lists)
  (if (null? lists) lists (append (car lists) (append-all (cdr lists)))))

(define (count-distinct list)
  (letrec ((count-aux (lambda (list distinct)
                        (if (null? list)
                            (length distinct)
                            (if (member (car list) distinct)
                                (count-aux (cdr list) distinct)
                                (count-aux (cdr list) (cons (car list) distinct)))))))
    (count-aux list ())))

(define (can-use-node-part1 node curr-path)
  (or (big-cave? node) (not (member node curr-path))))

(define (can-use-node-part2 node curr-path)
  (or (big-cave? node)
      (and (not (equal? node "start"))
           (let* ((small-caves (filter small-cave? (cons node curr-path))))
             (<= (length small-caves) (+ (count-distinct small-caves) 1))))))

(define (valid-paths graph filter-func)
  (letrec ((paths (lambda (end curr-path)
                    (let ((curr (car curr-path)))
                      (if (equal? curr end)
                          (list (reverse curr-path))
                          (let* ((neighbors (assoc-get graph curr ()))
                                 (valid-neighbors (filter (lambda (node) (filter-func node curr-path)) neighbors))
                                 (opts (map (lambda (next) (paths end (cons next curr-path))) valid-neighbors)))
                            (append-all opts)))))))
    (paths "end" (list "start"))))

(begin
  (let* ((source (open-input-file "inputs/12.input"))
         (empty-graph (assoc-init))
         (graph (read-input source empty-graph))
         (paths-1 (valid-paths graph can-use-node-part1))
         (paths-2 (valid-paths graph can-use-node-part2)))
    (display "Part 1: ")
    (display (length paths-1))
    (display "\n")
    (display "Part 2: ")
    (display (length paths-2))
    (display "\n")
    (close-input-port source)))
